---
title: "A summary of the tidyverse"
author: "Jaime Davila"
date: "2/2/2022"
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Transforming and visualizing with tidyverse

`tidyverse` is a powerful collection of functions and libraries that allows us interact and wrangle datasets in an effective manner. Before we use any of those commands we need to instruct R to the `tidyverse` library which can be done with the following command:

```{r warning=FALSE, message=FALSE}
library(tidyverse)  
```

During this session we will be analyzing datasets from [Defining the '90s Music Cannon ](https://pudding.cool/2020/07/song-decay/) so we will start by using `read_csv` to load our dataset into the tibble `song.year.tbl`.

```{r message=FALSE}
#file.path="../data/song.year.csv"
file.path="~/Mscs 341 S22/Class/Data/song.year.csv"
song.year.tbl <- read_csv(file.path)
song.year.tbl
```

## A first plot

We will start by doing a simple plot summarizing the number of songs per year of our dataset by using `ggplot`. A good presentation of `ggplot` can be found in [Chapter 3:Data Visualization](https://r4ds.had.co.nz/data-visualisation.html). A couple of quick things to note about this code:

* We will be using `geom_histogram` as our geometric object
* Notice that since`year` is a number we need to convert it to a categorical variable using the command `as.factor`

```{r warning=FALSE}
ggplot(song.year.tbl, aes(x=as.factor(year)))+
  geom_histogram(stat="count")+
  labs(x="Year")
```


## A first summary

We can obtain the number of songs by combining the commands `group_by` and `summarize`.Again notice that:

* We are using the pipe (%>%) to combine the two commands together.
* `group_by` can take as an argument any combination of the columns from the tibble.
* `summarize` is a very flexible command and allows the calculation of any number of statistics like average, minimum or maximum. In this particular case we are just counting the number of elements by using the function `n()`.

```{r}
song.year.tbl %>%
  group_by(year) %>%
  summarize(n=n())
```

## Transforming datasets

Before attempting the following exercises we recommend that you read [Chapter 5: Data Transformation] (https://r4ds.had.co.nz/transform.html).

In particular we will be using the following 7 commands (also called verbs) from `tidyverse`

 * `group_by`
 * `summarize`
 * `slice`
 * `arrange`
 * `select`
 * `filter`
 * `mutate`

1. In the following exercises we will modify our original dataset to answer specific questions:

    a. Generate a table with top-5 artists from the 90s according to their number of songs and call it `top5.tbl`. 

```{r echo=FALSE, message=FALSE}
top5.tbl <- song.year.tbl %>%
  group_by(artist) %>%
  summarize (n=n()) %>%
  arrange(desc(n)) %>%
  slice(1:5)
```

    b. Let's explore Mariah Carey's career in depth. Start by summarizing the number of hits of Mariah Carey by year and find out what was her best year.
```{r echo=FALSE, message=FALSE}
song.year.tbl %>%
  filter(artist == "Mariah Carey") %>%
  group_by(year) %>%
  summarize (n=n()) %>%
  arrange(desc(n))
```

    c. What are the songs from her best year? Do you recognize any of them?
```{r echo-FALSE, message=FALSE}
song.year.tbl %>%
  filter(artist == "Mariah Carey" & year==1991) %>%
  select(song)
```

2. It seems like some artists like Mariah Carey had a song in the billboard in every year of the 90s decade, while others only had one hit in the entire decade. 

    a. We are interested in calculating the `year.span` of an artist, which is basically defined as the difference in years between their latest and earliest song in the 90s. Create a table `artist.span.tbl` with such information and include `earliest.year` and `latest.year` as columns:

```{r,message=FALSE,echo=FALSE}
artist.span.tbl <- song.year.tbl %>%
  group_by(artist) %>%
  summarize (n=n(),
             earliest.year=min(year), 
             latest.year=max(year)) %>%
  mutate(year.span = latest.year - earliest.year +1)
```

    b. What are the top-5 artists with biggest span?

```{r echo=FALSE, message=FALSE}
artist.span.tbl %>%
  arrange(desc(year.span)) %>%
  select(artist, n, year.span) %>%
  slice(1:5)
```

    c. Generate a histogram describing the span across all the artist in our table:

```{r echo=FALSE, message=FALSE}
artist.span.tbl %>%
  ggplot(aes(x=year.span))+
    geom_histogram()
```

3. Create a table with year and number of songs by artist and year. Only select artists that had at least 3 hits in a year. Generate a graph depicting this info.

```{r message=FALSE, echo=FALSE}
top.tbl <- song.year.tbl %>%
  group_by(artist,year) %>%
  summarize(n=n()) %>%
  arrange(desc(n)) %>%
  filter(n>=3)
top.tbl

top.tbl %>%
  ggplot(aes(x=year, y=n, fill=artist))+
  geom_bar(stat="identity")
```

# Joinining datasets

A common situation in analysis is that all of the information is not contained in just a single dataset. Let's start by loading a different dataset which has recognition metrics for all of our previous songs


```{r warning=FALSE, message=FALSE}
#file.path="../data/song.recognition.csv"
file.path="~/Mscs 341 S22/Class/Data/song.recognition.csv"

song.recognition.tbl <- read_csv(file.path)
```

Notice how `song.recognition.tbl` has `artist`, `song`, `generation` and `recognition` as variables. `generation` is measured as the age of the respondents when the song was released. For example, Macarena was released in 1996, so -10 represents the people who *were 10 years old* when it was released (and were born in 1986), while 5 represents the people who *were born 5 years after the song* (and were born in 2001).

Let's take a look at the entire dataset using a boxplot

```{r}
ggplot(song.recognition.tbl, aes(as.factor(generation), recognition)) +
  geom_boxplot()+
  labs(x="Generation")
```

In the following exercises we will explore this dataset in more detail. Make sure to consult  [Chapter 13:Relational data](https://r4ds.had.co.nz/relational-data.html) and pay close attention to the function `inner_join()`

4. Let's explore  the decaying trend in recognition is the same according to the year that the song came out. Let's do that using the following steps:

    1. Combine `song.recognition.tbl` and `song.year.tbl` in a single table called `song.decay.tbl`
    
```{r echo=FALSE, message=FALSE}
song.decay.tbl <-  inner_join(song.recognition.tbl, song.year.tbl)
```
    
    2. Create the following which shows the trends for each different year. As the years get closer to the end of the decade we get a lot of observations where the y value is 0. Can you explain why?

```{r echo=FALSE, message=FALSE}
ggplot(song.decay.tbl, aes(x = generation, y = recognition)) +
  geom_point(alpha=0.3) +
  geom_smooth(method="lm")+
  facet_wrap(vars(year), nrow=2)
```

5. Let's look at the trends for the top 5 most popular artist by doing a join with `top5.tbl` and subset to only negative generations. 


    1. Plot the trends for every artist. Who is the most recognized artist (dare I say *diva*) from the 90s? 


    2. Look at the individual trends for each artist by generating the following plot.
   

6. In the following exercise let's focus on songs by Whitney Houston.

    1. Identify the most and least recognized songs by Whitney Houston by generating the following plot
   

    2. Modify the previous plot so that the names are in order of recognition (*Hint*: Create a new categorical variable where the levels are arranged according to the average song recognition)


7. In this exercise we will plot the trends of particular sets of songs. For the purposes of the exercise we will subset `song.decay.tbl` to songs before generation 0


    1. Identify the top-5 songs with the highest recognition and plot their trends. Make sure to use `inner_join`
    

  
    1. Identify the top-5 songs with the highest variability and plot their trends. Make sure to use `inner_join`
    

# Using pivots

Make sure to read [Chapter 12:Tidy data](https://r4ds.had.co.nz/relational-data.html) and keep in mind the following commands:

* `pivot_longer`
* `pivot_wider`
* `separate`


8. We are interested in calculating how people from different generation remember songs from the 90s. In particular we are interested in calculating the average song recognition across milennials (people born between 1980 to 1994) and generation Z (people born after 1994)

To do that create a new table using the following steps:
 
 * Calculate the year a person was born based on the `year` and `generation` fields.
 
 * Keep only entries of people who were born starting in 1980.
 
 * People who were born between 1980 and 1994 will be milennials and the rest will be generation Z.
 
  * Finally calculate the average recognition grouping by the generational group
 
  * Name the resulting table `song.gen.tbl`


9. As we can see `song.gen.tbl` has one different row for each `generation.group`, however we would like to have just one row per song and have columns with the average recognition for each generation. Use a pivot function to obtain the following table and name it `song.pivot.tbl`


10. Consider one of the tables for the original publication `time.series.tbl`

```{r message=FALSE}
url <- "https://raw.githubusercontent.com/the-pudding/song-decay-clean/master/src/assets/data/time_series_90s_july13.csv"
time.series.tbl <- read_csv(url)
time.series.tbl
```

Convert this table into a table with the following format (Note that generation is an integer and recognition is a double) and make sure to subset generation from `-13` to `10`



