---
title: "A summary of the tidyverse"
author: "Ivana K."
date: "2/2/2022"
output:
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
Review of last time: 
vectors:
  [] 
  typeof()
  length()
  
*Lists: can combine things of different types
some operators: 
  $
  [[]]
  
Tibble/Data frame: 
  these are lists. 
  
Factor: 
  it is a vector of integers with levels. levels = different categories that factor can take. 
  
matrices:
  elements all of same type
  

  









# Transforming and visualizing with tidyverse

`tidyverse` is a powerful collection of functions and libraries that allows us interact and wrangle datasets in an effective manner. Before we use any of those commands we need to instruct R to the `tidyverse` library which can be done with the following command:

```{r warning=FALSE, message=FALSE}
library(tidyverse)  
```

During this session we will be analyzing datasets from [Defining the '90s Music Cannon ](https://pudding.cool/2020/07/song-decay/) so we will start by using `read_csv` to load our dataset into the tibble `song.year.tbl`.

```{r message=FALSE}
file.path="C:/Users/ivana/Desktop/RFiles/song_year.csv"
song.year.tbl <- read_csv(file.path)
song.year.tbl
```

## A first plot

We will start by doing a simple plot summarizing the number of songs per year of our dataset by using `ggplot`. A good presentation of `ggplot` can be found in [Chapter 3:Data Visualization](https://r4ds.had.co.nz/data-visualisation.html). A couple of quick things to note about this code:

* We will be using `geom_histogram` as our geometric object
* Notice that since`year` is a number we need to convert it to a categorical variable using the command `as.factor`

```{r warning=FALSE}
ggplot(song.year.tbl, aes(x=as.factor(year)))+
  geom_histogram(stat="count")+
  labs(x="Year")
```


## A first summary

We can obtain the number of songs by combining the commands `group_by` and `summarize`.Again notice that:

* We are using the pipe (%>%) to combine the two commands together.
* `group_by` can take as an argument any combination of the columns from the tibble.
* `summarize` is a very flexible command and allows the calculation of any number of statistics like average, minimum or maximum. In this particular case we are just counting the number of elements by using the function `n()`.

```{r}
song.year.tbl %>%
  group_by(year) %>%
  summarize(n=n())
```

## Transforming datasets

Before attempting the following exercises we recommend that you read [Chapter 5: Data Transformation] (https://r4ds.had.co.nz/transform.html).

In particular we will be using the following 7 commands (also called verbs) from `tidyverse`

 * `group_by`
 * `summarize`
 * `slice`
 * `arrange`
 * `select`
 * `filter`
 * `mutate`

1. In the following exercises we will modify our original dataset to answer specific questions:

    a. Generate a table with top-5 artists from the 90s according to their number of songs and call it `top5.tbl`. 

```{r}
top5.tbl <- song.year.tbl %>%
  group_by(artist) %>%# not group by year. why?
  summarize(n = n()) %>%# more efficient way to clear repeats?
  arrange(desc(n)) %>% 
  slice(1:5)
```

    b. Let's explore Mariah Carey's career in depth. Start by summarizing the number of hits of Mariah Carey by year and find out what was her best year.
```{r}
song.year.tbl %>%
  group_by(artist, year) %>%# need to combined 2 Pac = 2Pac
  summarize(n = n()) %>%
  filter(artist == "Mariah Carey") %>%
  arrange(desc(n))
```
Best year was 1991 with n = 3 top songs.

solution:
```{r}
song.year.tbl %>%
  filter(artist == "Mariah Carey") %>%
  group_by(year) %>%
  summarize(n = n()) %>%
  arrange(desc(n))
```

    c. What are the songs from her best year? Do you recognize any of them?
```{r}
song.year.tbl %>%
  filter(artist == "Mariah Carey") %>%
  filter(year == 1991) %>%
  select(song)
```
Emotions, I Don't Wanna Cry, and Someday
I recognize the first song because Ariana Grande sang it. 
solution: see where it is
    
2. It seems like some artists like Mariah Carey had a song in the billboard in every year of the 90s decade, while others only had one hit in the entire decade. 

    a. We are interested in calculating the `year.span` of an artist, which is basically defined as the difference in years between their latest and earliest song in the 90s. Create a table `artist.span.tbl` with such information and include `earliest.year` and `latest.year` as columns:

```{r}
artist.span.tbl <- song.year.tbl %>%
  group_by(artist) %>%
  summarize(n = n(), 
            earliest.year = min(year), 
            latest.year = max(year)) %>%
  mutate(year.span = latest.year - earliest.year + 1) %>%
  arrange(desc(year.span))
artist.span.tbl
```

    b. What are the top-5 artists with biggest span?
Mariah Carey, Whitney Houston, Mariah Carey, Janet Jackson, Madonna
solution:
```{r}
artist.span.tbl %>%
  select(artist, n, year.span) %>%
  slice(1:5)
```

    c. Generate a histogram describing the span across all the artist in our table:
solution:
```{r}
artist.span.tbl %>%
  ggplot(aes(x=year.span)) + 
  geom_histogram()
```
solution: most artists have a span of just one year. They have one hit and are done.


3. Create a table with year and number of songs by artist and year. Only select artists that had at least 3 hits in a year. Generate a graph depicting this info.
solution:
```{r}
top.tbl <- song.year.tbl %>%
  group_by(artist, year) %>%
  summarize(n = n()) %>%
  arrange(desc(n)) %>%
  filter(n >= 3)
top.tbl

top.tbl %>%
  ggplot(aes(x = year, y = n, fill = artist)) + 
  geom_bar(stat = "identity")
```


# Joinining datasets

A common situation in analysis is that all of the information is not contained in just a single dataset. Let's start by loading a different dataset which has recognition metrics for all of our previous songs

```{r warning=FALSE, message=FALSE}

file.path="C:/Users/ivana/Desktop/RFiles/song.recognition.csv"

song.recognition.tbl <- read_csv(file.path)
song.recognition.tbl
```

Notice how `song.recognition.tbl` has `artist`, `song`, `generation` and `recognition` as variables. `generation` is measured as the age of the respondents when the song was released. For example, Macarena was released in 1996, so -10 represents the people who *were 10 years old* when it was released (and were born in 1986), while 5 represents the people who *were born 5 years after the song* (and were born in 2001).

Let's take a look at the entire dataset using a boxplot

```{r}
ggplot(song.recognition.tbl, aes(as.factor(generation), recognition)) +
  geom_boxplot()+
  labs(x="Generation")
```

In the following exercises we will explore this dataset in more detail. Make sure to consult  [Chapter 13:Relational data](https://r4ds.had.co.nz/relational-data.html) and pay close attention to the function `inner_join()`

4. Let's explore  the decaying trend in recognition is the same according to the year that the song came out. Let's do that using the following steps:

    1. Combine `song.recognition.tbl` and `song.year.tbl` in a single table called `song.decay.tbl`
```{r}
head(song.recognition.tbl)#artist, song, generation, recognition
head(song.year.tbl)#artist, song, year
```

```{r}
song.decay.tbl <- inner_join(song.recognition.tbl, song.year.tbl, by = c("artist", "song"))
song.decay.tbl
```


    2. Create the following which shows the trends for each different year. As the years get closer to the end of the decade we get a lot of observations where the y value is 0. Can you explain why?
**consult pdf, prof says
why are the direction's numbers out of order? 2 5 1 2 etc
solution:
```{r}
ggplot(song.decay.tbl, aes(x = -generation, y = recognition)) + 
  geom_point(alpha = 0.3) + 
  geom_smooth(method = "lm") + 
  facet_wrap(vars(year), nrow = 2)
```

    5. Let's look at the trends for the top 5 most popular artist by doing a join with `top5.tbl` and subset to only negative generations. 
    
    1. Plot the trends for every artist. Who is the most recognized artist (dare I say *diva*) from the 90s? 
```{r}
top5.tbl %>%
  left_join(song.decay.tbl, by = "artist") %>%
  filter(generation < 0) %>%
  ggplot() + 
    geom_point(mapping = aes(x = generation, y = recognition, color = artist)) +
    geom_smooth(method = 'lm', mapping = aes(x = generation, y = recognition, color = artist))
```
I think Whitney Houston might win out. Madonna also had a big presence. It is difficult to tell. I think this could be determined based on an integral of the largest area under each slope. 

    2. Look at the individual trends for each artist by generating the following plot.
```{r}
top5.tbl %>%
  left_join(song.decay.tbl, by = "artist") %>%
  filter(generation < 0) %>%
  ggplot() + 
    geom_point(mapping = aes(x = generation, y = recognition)) +
    geom_smooth(method = 'lm', mapping = aes(x = generation, y = recognition, group = song)) +
  facet_wrap(~ artist, nrow = 2)
```

6. In the following exercise let's focus on songs by Whitney Houston.

    1. Identify the most and least recognized songs by Whitney Houston by generating the following plot
```{r}
top5.tbl %>%
  left_join(song.decay.tbl, by = "artist") %>%
  filter(generation < 0 ) %>%
  filter(artist == "Whitney Houston") %>%
  ggplot() + 
    geom_point(mapping = aes(x = generation, y = recognition, color = song)) +
    geom_smooth(method = 'lm', mapping = aes(x = generation, y = recognition, color = song))
```
Most: I will always love you. 
Least: Heartbreak Hotel

    2. Modify the previous plot so that the names are in order of recognition (*Hint*: Create a new categorical variable where the levels are arranged according to the average song recognition)
```{r}
top5.tbl %>%
  left_join(song.decay.tbl, by = "artist") %>%
  filter(generation < 0 ) %>%
  filter(artist == "Whitney Houston") %>%
  mutate(song = fct_reorder(song, desc(recognition))) %>%
  ggplot() + 
    geom_point(mapping = aes(x = generation, y = recognition, color = song)) +
    geom_smooth(method = 'lm', mapping = aes(x = generation, y = recognition, color = song))
```

7. In this exercise we will plot the trends of particular sets of songs. For the purposes of the exercise we will subset `song.decay.tbl` to songs before generation 0
```{r}
song.decay.filter.tbl <- song.decay.tbl %>%
  filter(generation<0)
song.decay.filter.tbl
```

    1. Identify the top-5 songs with the highest recognition and plot their trends. Make sure to use `inner_join`
```{r}
table <- song.decay.filter.tbl %>%
  inner_join(song.year.tbl, by = c("artist", "song")) %>%
  group_by(artist, song) %>%
  summarize(net_recognition = sum(recognition)) %>%
  arrange(desc(net_recognition)) %>%
  #slice(1:5)
  ungroup() %>%
  slice_max(net_recognition, n = 5)

table

table2 <- table %>%
  left_join(song.decay.filter.tbl, by = c("artist", "song"))
table2

table2 %>%
  ggplot() +
    geom_point(mapping = aes(x = generation, y = recognition, color = song)) + 
    geom_smooth(method = 'lm', mapping = aes(x = generation, y = recognition, color = song), se=FALSE)
```
There is probably a better way to do this.

    1. Identify the top-5 songs with the highest variability and plot their trends. Make sure to use `inner_join`
```{r}

table3 <- song.decay.filter.tbl %>%
  inner_join(song.year.tbl, by = c("artist", "song")) %>%
  group_by(song, artist) %>%
  summarize(max = max(recognition),
            min = min(recognition),
         diff = (max - min)) %>%
  arrange(desc(diff)) %>%
  ungroup() %>%
  slice_max(diff, n = 5)

table3

table4 <- table3 %>%
  left_join(song.decay.filter.tbl, by = c("artist", "song"))
table4

table4 %>%
  ggplot() +
    geom_point(mapping = aes(x = generation, y = recognition, color = song)) + 
    geom_smooth(method = 'lm', mapping = aes(x = generation, y = recognition, color = song), se=FALSE)
```
For some reason, two of my songs are different from the answer-pdf. 
May be due to how R calculates numbers but - oh well! Good enough I hope.

# Using pivots

Make sure to read [Chapter 12:Tidy data](https://r4ds.had.co.nz/relational-data.html) and keep in mind the following commands:

* `pivot_longer`
* `pivot_wider`
* `separate`


8. We are interested in calculating how people from different generation remember songs from the 90s. In particular we are interested in calculating the average song recognition across milennials (people born between 1980 to 1994) and generation Z (people born after 1994)

To do that create a new table using the following steps:
 
load in data again so it's fresh:
```{r warning=FALSE, message=FALSE}

file.path="C:/Users/ivana/Desktop/RFiles/song.recognition.csv"
song.recognition.tbl <- read_csv(file.path)

file.path="C:/Users/ivana/Desktop/RFiles/song_year.csv"
song.year.tbl <- read_csv(file.path)

song.recognition.tbl#artist, song, generation, recognition
song.year.tbl#artist, song, year

song.decay.tbl2 <- inner_join(song.recognition.tbl, song.year.tbl, by = c("artist", "song"))
song.decay.tbl2
```
 
 * Calculate the year a person was born based on the `year` and `generation` fields.
 
 * Keep only entries of people who were born starting in 1980.

 * People who were born between 1980 and 1994 will be milennials and the rest will be generation Z.

  * Finally calculate the average recognition grouping by the generational group
 
  * Name the resulting table `song.gen.tbl`
```{r}
song.gen.tbl <- song.decay.tbl2 %>%
  mutate(birthyear = (year + generation)) %>%
  filter(birthyear >= 1980) %>%
  mutate(generation.group = ifelse((birthyear <= 1994 & birthyear >= 1980), "Millennial", "Z")) %>%
  group_by(song, generation.group) %>%
  filter(recognition != 0) %>%
  summarize(av_recognition = mean(recognition))

song.gen.tbl
```

9. As we can see `song.gen.tbl` has one different row for each `generation.group`, however we would like to have just one row per song and have columns with the average recognition for each generation. Use a pivot function to obtain the following table and name it `song.pivot.tbl`
```{r}
song.gen.tbl %>%
  pivot_wider(names_from = generation.group, values_from = av_recognition)
```

10. Consider one of the tables for the original publication `time.series.tbl`

```{r message=FALSE}
url <- "https://raw.githubusercontent.com/the-pudding/song-decay-clean/master/src/assets/data/time_series_90s_july13.csv"
time.series.tbl <- read_csv(url)
time.series.tbl
```

Convert this table into a table with the following format (Note that generation is an integer and recognition is a double) and make sure to subset generation from `-13` to `10`
```{r}
time.series.tbl %>%
  pivot_longer(`-13`:`34`, names_to = "generation", values_to = "recognition") %>%
  separate(artist_song, into = c("artist", "song"), sep = "\\|\\|\\|") %>% mutate(generation = as.integer(generation)) %>%
  filter(generation < 11)
```






HW hints: 
levels: c("", "", "")
mutate(song = as.factor(song levels = song.sort))

recognition: many values are 0 because people aren't old enough to answer.
****see where mean is used
try this for the graphs that don't match up. 
also try this for the table.